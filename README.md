[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15568699&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
Software engineering involves software product design, development, testing, deployment and maintenance through the application of principles, methods, and tools to develop and maintain high-quality software systems.
Software engineering plays a crucial role in the technology industry by enabling the creation of Software applications and systems that power various aspects of modern life, including communication, commerce, entertainment and healthcare.

Identify and describe at least three key milestones in the evolution of software engineering.
The evolution of Software engineering has been shaped by many important milestones that have endearingly shaped the field These important milestones are:
 
The Birth of High-Level Programming Languages(1950s-1960s).
During this period, programming machine code assembly language was time consuming and error-prone.Software engineering was marked by a significant milestone, development of high-level programming languages like FORTRAN(1957), COBOL (1959) and AGOL( 1960). Through these languages programmers were able to write code that was more abstract, easier to understand, and closer to human language.
Therefore, high-level languages increased productivity, reduced the probability for errors, and made programming more accessible to a wider range of people. This development laid the foundation for the development of modern programming languages and software development practices.

The Emergence  of Structured Programming (1960s-1970s).
Structured programming was introduced as a response to the difficulty and lack of discipline in early programming practices. Popularised by Edsger Dijkstra, emphasised the use of control structures like loops, conditionals, and subroutines to improve the clarity and quality of code. It was supported by the introduction of languages like Pascal (1970) and C (1972).
Structured programming led to more organised, maintainable, and reliable code. It did set the stage for later advancements in Software engineering, such as object-oriented programming and software design patterns.

The Ascent of Agile Methodology (1990s-2000s).
Around this period, traditional software development models like the Waterfall model were criticised for being too rigid and not allowing changes well. This led to the development of Agile methodologies, which emphasised repetitive development, customer collaboration, and flexibility. The Agile Manifesto, formally defined the principles of Agile Software Development was then published in 2001.
Agile Methodology transformed the Software Engineering industry by promoting faster development cycles, continuous feedback, and the ability to adapt to changing requirements. Today, it is one of the most widely adopted approaches in Software development, influencing many other methodologies such as Scrum, Kanban, and DevOps.

List and briefly explain the phases of the Software Development Life Cycle.
A full Software Development Life cycle has 7 Basic Stages;
Planning.
In this phase, Planning involves defining the Software’s purpose and scope, much like pinpointing our destination and plotting the best route. The project leads to defining the project’s purpose, strategizing for efficient execution and desired result.
Requirements
In this Phase, the needs and expectations of the stakeholders are gathered and analysed. The goal is to clearly define what software should do, who will use it, and under what conditions. This phase results in a detailed requirements specification document that serves as a guideline for the rest of the project.
Design and Prototype.
The Design phase is all about building the framework.The development team is responsible for software engineering and outlines the software’s functionality and aesthetic. This ultimately results in the Software product. The emphasis lies on outlining the software’s structure, navigation, user interfaces, and database design. This phase ensures that the software is user-friendly and performs its tasks efficiently.
Coding.
The Coding phase is when engineers and developers get down to business and start converting the Software design into tangible code. This phase aims to develop software that is functional, efficient, and user-friendly. Developers use an appropriate programming language, java or otherwise, to write the code, guided by the SDD and coding guidelines. This document, acting as a roadmap, ensures the software aligns with the vision set in earlier phases.
Testing.
After coding, the software is rigorously tested to identify and fix any bugs or defects. This phase ensures that the software functions as intended, meets the requirements, and if free of errors. Testing can include unit testing, integration testing, and user acceptance testing (UAT).
Deployment.
Once the software has been thoroughly tested and is deemed ready for use, it is deployed to the production environment where users can access and use it. This phase may involve installing the software on users devices, setting up the necessary infrastructure, and configuring the system.
Maintenance.
After deployment , the software enters the maintenance phase where it is monitored and updated as needed. This phase involves fixing any issues that arise, making improvements, and adding new features to keep the software relevant and functional over time. Maintenance can also involve regular updates and patches.

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.

Agile Methodology is a dynamic and interactive approach that focuses on continuous improvement, flexibility, and high levels of team involvement. It's designed to accommodate changes and feedback quickly, typically through regular feedback loops that help refine and improve the development process whereas, Waterfall Methodology is a sequential process where fixed, defined requirements are identified early in the project process.It involves progressing through a series of distinct phases- concept, initiation, analysis, design, construction, testing, implementation, and maintenance- with each phase completed before the next begins.
Agile methodology’s requirements can evolve throughout the project, with regular feedback from stakeholders guiding the development process whereas, Waterfall methodology’s requirements are defined at the beginning of the project and are expected to remain unchanged throughout the development process.
Examples of the scenarios where each would be appropriate include:
Agile Methodology is ideal for projects where requirements are expected to change or are not fully understood at the start, such as developing a new mobile app in a competitive market where user needs may evolve whereas Waterfall methodology is suitable for projects with clearly defined requirements that are unlikely to change, such as developing a regulatory compliance system where the requirements are fixed.
Agile Methodology allows for ongoing adjustments and improvements for large projects where incremental delivery can provide value and feedback throughout the process whereas Waterfall methodology if the project is short-term and scope is well understood, waterfall can provide a straightforward approach.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

A Software engineer is responsible for writing the code and developing the entire software product. Beside coding, a software developer is responsible for sending updates to the project manager and working closely with other team members, including the designer and quality assurance engineer.
The roles and responsibilities of a Software developer include:
Developing applications, programs and systems using programming languages and frameworks.
Maintaining and updating software to keep it functional.
Collaborating with other team members to ensure best practices when developing software.
Report to the project manager about the progress of the software development.

A Quality Assurance (QA) Engineer creates tests that identify issues with software before it is deployed. He/She monitors every phase of the software development process, including development, testing, debugging and delivery. They ensure that quality is maintained at every stage of the development process and that the final product meets the requirements.
The roles and responsibilities of a Quality Assurance Engineer include:
Confirming that the software meets the requirements before deployment.
Analyse the product to identify bugs and suggest changes to make them more efficient.
Create development standards and procedures for the programmers to follow.
Collaborate with stakeholders to understand and clarify software requirements.
Develop and execute automation scripts using open-source tools.

A Project Manager oversees the project’s progress, manages resources, coordinates the team, and ensures that the project is completed on time, within scope, and within budget.
The role and responsibilities of a Project manager:
Defining the project’s scope, objectives, and deliverables. They create a project plan, including timelines, milestones, resource allocation, and budget management.
Coordinates the efforts of the software development team, ensuring that all the team members are aligned with the project’s goals and timelines.
Identify potential risks to the project's success, such as delays, scope changes, or technical challenges, and develop mitigation strategies to address these risks.
They are responsible for resolving conflicts, where they are related to team dynamics, resource constraints, or project requirements. They work to keep the project on track by addressing issues as they arise.

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

Integrated Development Environments(IDEs) is a software suite that consolidates basic tools required to write and test software.
Importance of IDEs include;
IDEs provide features like syntax highlighting, code completion, and code templates, which help developers write code more quickly and accurately. These features reduce the likelihood of syntax errors and increase coding efficiently.
IDEs offer built-in debugging tools that allow developers to set breakpoints, inspect variables, and step through code execution. This makes it easier to identify and fix bugs during development.
IDEs often integrate various tools such as compilers, interpreters, linters, and testing frameworks. This integration streamlines the development process, as developers can compile code, run tests, and analyse code quality from within a single interface.

Examples of IDEs are;
Visual Studio; - A powerful IDE primarily used for NET and C++ development, which offers extensive tools for building and debugging applications.
PyCharm; - Specifically designed for python development, PyCharm offers features like code inspections, a powerful debugger, and support for web frameworks like Django and Flask.
IntelliJ IDEA: - Popular for Java development, IntelliJ IDEA provides intelligent code assistance, refactoring tools, and a rich set of plugins for various languages and frameworks.

Version Control Systems (VCS) are software tools that help software teams manage changes to source code overtime. As development environments have accelerated, version control systems help software teams work faster and smarter.

Importance of  Version Control Systems (VCS);
Collaboration and Teamwork: VCS allows multiple developers to work on the same project simultaneously without overwriting each other's changes. It manages code conflicts and merges, enabling smooth collaboration across teams, regardless of geographic location.
Tracking Changes: VCS tracks every change made to the codebase overtime, providing a detailed history of who made changes, what was changed, and why. This historical data is invaluable for understanding code evolution and for auditing purposes.
Branching and Merging: Developers can create branches to work on features, bug fixes, or experiments independently of the main codebase. Once the work is complete, it can be merged back into the main branch, enabling parallel development and reducing the risk of introducing unstable code into the production environment.

Examples of VCS are:
Git: The most widely used continuous integration (CI) and Continuous Deployment (CD) pipelines. Automated systems can trigger builds, tests, and deployments based on code changes pushed to the repository, ensuring that the latest version of the software is always ready for release.
Mercurial: Another distributed VCS similar to Git, valued for its simplicity and performance, particularly in handling large projects.
Subversion (SVN): A centralised VCS that is still in use in many organisations, offering strong support for versioned  directories and atomic commits, though it lacks some of the distributed features of Git.

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.

Lack of Workflow Visibility: Failure to acknowledge the visibility issue or brush it aside, and in no time your team may get beset by a plethora of business and software engineering challenges that sprout due to lack of visibility. By investing in tools that empower your teams to make data-driven decisions: For instance, project managers can estimate timelines that are evidence-based and feasible. Engineering managers can evenly allocate work to software engineers based on individual capacity, workload, and expertise. Thus, saving your champions from the dreaded burnout while optimally utilising their talent.
Broken SDLC Processes : Some of the execution challenges that engineers may experience are like their software development processes being broken at multiple levels due to them not defining processes/procedures and also lack of documentation and training. Software engineers can solve this by managing their workflow, scoping iterations accurately using data-driven insights and removing the persistent SDLC blockers by inspecting,detecting, and fixing the root cause.
Debugging & Troubleshooting: Fixing bugs, especially in complex systems,can be time consuming and frustrating. Some of the Strategies that engineers can use: Leveraging integrated debugging tools in your IDE to step through code and inspect variables, implementing comprehensive logging and monitoring to track down issues more effectively and break down the problem into smaller parts, isolate the issue, and test assumptions to find the root cause.
Security concerns: Ensuring that software is secure against vulnerabilities and attacks is increasingly important and challenging. Some of the strategies that engineers can use: Follow security best practices, such as input validation, encryption, and secure coding guidelines, Conduct regular security audits and penetration testing to identify and fix vulnerabilities and keep up with the latest security trends and vulnerabilities to ensure their software is protected against new threats.
Meeting Deadlines: Delivering a project on time while maintaining quality is often challenging, especially when unforeseen issues arise. Some of the strategies that software engineers can use are; use of project management tools to plan and track progress, breaking down tasks into manageable chunks with clear deadlines, build in buffer time for unexpected delays, ensuring that the project stays on track even if issues arise, identify the critical path of the project and ensure that resources are allocated to the most important tasks to avoid bottlenecks.

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

In software testing, there are four levels of testing, such as:
Unit testing: This is the first level of testing that determines whether or not software components fulfil functionalities. It is critical for maintaining code quality and catching bugs early.
Integration testing This is the second level of testing that verifies data flow from one module to another. It ensures that the various components of the software work together correctly.
System testing: This is the third level of testing that examines both functional and non-functional testing requirements. It verifies that the entire system functions according to the specified requirements, examines the software’s behaviour in a fully integrated environment, including interactions with external systems if applicable.
Acceptance testing: This is the fourth level of testing that verifies that the requirements have been met. It ensures that the software meets the end user’s expectations and business requirements and confirms that the software can handle real-world scenarios and workflows.


#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.

Prompt engineering is all about crafting questions or statements to get the best possible responses from AI models, particularly those based on natural language processing(NLP) like OpenAI’s GPT. The goal is to prompt that elicit desired outputs from the AI by clearly and specifically instructing the model on what is expected.
Prompt engineering makes it easy for the users to obtain relevant results in the first prompt. It helps mitigate bias that may be present from existing human bias in the large language models’ training data. Further, it enhances the user-AI interaction so the AI understands the user's intention even with minimal input.

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

Example of a Vague Prompt; “Explain history”.

Issues with the Vague Prompt:
No focus area. It doesn’t specify which aspect of history (e.g., a particular event, region, or era) the user is interested in.
 Too Broad: The prompt is extremely broad, covering an enormous span of time and countless events. The AI could respond with anything from ancient civilizations to modern history, making it hard to provide a focused answer.
Unclear purpose: The prompt lacks direction, leading to a response that may not meet the user’s needs.

Improved Prompt:
“Provide a brief overview of the causes and consequences of the French Revolution, focusing on its impact on European political systems.

Reason to why the improved prompt is more effective:
It's a clear focus. The prompt specifies that the discussion should centre on the French Revolution, which narrows down the scope and makes it easier for the AI to generate a relevant response.
It has a direct outcome: By focusing on the impact on European political systems, the user guides the AI to highlight the broader significance of the French Revolution, making the answer more meaningful and relevant.
It has Specific details: It asks for information on both the causes and consequences, ensuring the response is comprehensive but focused on a particular event and its implications.




